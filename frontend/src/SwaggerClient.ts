/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.6.2.0 (NJsonSchema v10.1.23.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import axios, {
  AxiosError,
  AxiosInstance,
  AxiosRequestConfig,
  AxiosResponse,
  CancelToken,
} from 'axios'

export class Client {
  private instance: AxiosInstance
  private baseUrl: string
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl ? baseUrl : ''
  }

  /**
   * @param version The requested API version
   * @return Success
   */
  getStatusJwt(
    version: string,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + '/api/v{version}/auth/jwt/status'
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.")
    url_ = url_.replace('{version}', encodeURIComponent('' + version))
    url_ = url_.replace(/[?&]$/, '')

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {},
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetStatusJwt(_response)
      })
  }

  protected processGetStatusJwt(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      )
    }
    return Promise.resolve<void>(<any>null)
  }

  /**
   * @param version The requested API version
   * @return Success
   */
  getStatus(
    version: string,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + '/api/v{version}/auth/status'
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.")
    url_ = url_.replace('{version}', encodeURIComponent('' + version))
    url_ = url_.replace(/[?&]$/, '')

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {},
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetStatus(_response)
      })
  }

  protected processGetStatus(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      )
    }
    return Promise.resolve<void>(<any>null)
  }

  /**
   * @param ban_types (optional)
   * @param ban_types_list (optional)
   * @param is_expired (optional)
   * @param ip (optional)
   * @param steamid64 (optional)
   * @param steam_id (optional)
   * @param notes_contains (optional)
   * @param stats_contains (optional)
   * @param server_id (optional)
   * @param created_since (optional)
   * @param updated_since (optional)
   * @param offset (optional)
   * @param limit (optional)
   * @param version The requested API version
   * @return Success
   */
  get(
    ban_types: string | null | undefined,
    ban_types_list: string[] | null | undefined,
    is_expired: boolean | null | undefined,
    ip: string | null | undefined,
    steamid64: number | null | undefined,
    steam_id: string | null | undefined,
    notes_contains: string | null | undefined,
    stats_contains: string | null | undefined,
    server_id: number | null | undefined,
    created_since: Date | null | undefined,
    updated_since: Date | null | undefined,
    offset: number | null | undefined,
    limit: number | null | undefined,
    version: string,
    cancelToken?: CancelToken | undefined
  ): Promise<Ban_Public[]> {
    let url_ = this.baseUrl + '/api/v{version}/bans?'
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.")
    url_ = url_.replace('{version}', encodeURIComponent('' + version))
    if (ban_types !== undefined && ban_types !== null)
      url_ += 'ban_types=' + encodeURIComponent('' + ban_types) + '&'
    if (ban_types_list !== undefined && ban_types_list !== null)
      ban_types_list &&
        ban_types_list.forEach((item) => {
          url_ += 'ban_types_list=' + encodeURIComponent('' + item) + '&'
        })
    if (is_expired !== undefined && is_expired !== null)
      url_ += 'is_expired=' + encodeURIComponent('' + is_expired) + '&'
    if (ip !== undefined && ip !== null)
      url_ += 'ip=' + encodeURIComponent('' + ip) + '&'
    if (steamid64 !== undefined && steamid64 !== null)
      url_ += 'steamid64=' + encodeURIComponent('' + steamid64) + '&'
    if (steam_id !== undefined && steam_id !== null)
      url_ += 'steam_id=' + encodeURIComponent('' + steam_id) + '&'
    if (notes_contains !== undefined && notes_contains !== null)
      url_ += 'notes_contains=' + encodeURIComponent('' + notes_contains) + '&'
    if (stats_contains !== undefined && stats_contains !== null)
      url_ += 'stats_contains=' + encodeURIComponent('' + stats_contains) + '&'
    if (server_id !== undefined && server_id !== null)
      url_ += 'server_id=' + encodeURIComponent('' + server_id) + '&'
    if (created_since !== undefined && created_since !== null)
      url_ +=
        'created_since=' +
        encodeURIComponent(created_since ? '' + created_since.toJSON() : '') +
        '&'
    if (updated_since !== undefined && updated_since !== null)
      url_ +=
        'updated_since=' +
        encodeURIComponent(updated_since ? '' + updated_since.toJSON() : '') +
        '&'
    if (offset !== undefined && offset !== null)
      url_ += 'offset=' + encodeURIComponent('' + offset) + '&'
    if (limit !== undefined && limit !== null)
      url_ += 'limit=' + encodeURIComponent('' + limit) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'application/json',
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGet(_response)
      })
  }

  protected processGet(response: AxiosResponse): Promise<Ban_Public[]> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      if (Array.isArray(resultData200)) {
        result200 = [] as any
        for (let item of resultData200) result200!.push(Ban_Public.fromJS(item))
      }
      return result200
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      )
    }
    return Promise.resolve<Ban_Public[]>(<any>null)
  }

  /**
   * @param ban (optional)
   * @param version The requested API version
   * @return Success
   */
  post(
    ban: Ban | null | undefined,
    version: string,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + '/api/v{version}/bans'
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.")
    url_ = url_.replace('{version}', encodeURIComponent('' + version))
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(ban)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processPost(_response)
      })
  }

  protected processPost(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      )
    }
    return Promise.resolve<void>(<any>null)
  }

  /**
   * @param id (optional)
   * @param server_id (optional)
   * @param steamid64 (optional)
   * @param steam_id (optional)
   * @param jumptype (optional)
   * @param steamid64_list (optional)
   * @param jumptype_list (optional)
   * @param greater_than_distance (optional)
   * @param less_than_distance (optional)
   * @param json_jump_info (optional)
   * @param is_msl (optional)
   * @param is_crouch_bind (optional)
   * @param is_forward_bind (optional)
   * @param is_crouch_boost (optional)
   * @param updated_by_id (optional)
   * @param created_since (optional)
   * @param updated_since (optional)
   * @param offset (optional)
   * @param limit (optional)
   * @param version The requested API version
   * @return Success
   */
  get2(
    id: number | null | undefined,
    server_id: number | null | undefined,
    steamid64: number | null | undefined,
    steam_id: string | null | undefined,
    jumptype: string | null | undefined,
    steamid64_list: number[] | null | undefined,
    jumptype_list: number[] | null | undefined,
    greater_than_distance: number | null | undefined,
    less_than_distance: number | null | undefined,
    json_jump_info: string | null | undefined,
    is_msl: boolean | null | undefined,
    is_crouch_bind: boolean | null | undefined,
    is_forward_bind: boolean | null | undefined,
    is_crouch_boost: boolean | null | undefined,
    updated_by_id: number | null | undefined,
    created_since: Date | null | undefined,
    updated_since: Date | null | undefined,
    offset: number | null | undefined,
    limit: number | null | undefined,
    version: string,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + '/api/v{version}/jumpstats?'
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.")
    url_ = url_.replace('{version}', encodeURIComponent('' + version))
    if (id !== undefined && id !== null)
      url_ += 'id=' + encodeURIComponent('' + id) + '&'
    if (server_id !== undefined && server_id !== null)
      url_ += 'server_id=' + encodeURIComponent('' + server_id) + '&'
    if (steamid64 !== undefined && steamid64 !== null)
      url_ += 'steamid64=' + encodeURIComponent('' + steamid64) + '&'
    if (steam_id !== undefined && steam_id !== null)
      url_ += 'steam_id=' + encodeURIComponent('' + steam_id) + '&'
    if (jumptype !== undefined && jumptype !== null)
      url_ += 'jumptype=' + encodeURIComponent('' + jumptype) + '&'
    if (steamid64_list !== undefined && steamid64_list !== null)
      steamid64_list &&
        steamid64_list.forEach((item) => {
          url_ += 'steamid64_list=' + encodeURIComponent('' + item) + '&'
        })
    if (jumptype_list !== undefined && jumptype_list !== null)
      jumptype_list &&
        jumptype_list.forEach((item) => {
          url_ += 'jumptype_list=' + encodeURIComponent('' + item) + '&'
        })
    if (greater_than_distance !== undefined && greater_than_distance !== null)
      url_ +=
        'greater_than_distance=' +
        encodeURIComponent('' + greater_than_distance) +
        '&'
    if (less_than_distance !== undefined && less_than_distance !== null)
      url_ +=
        'less_than_distance=' +
        encodeURIComponent('' + less_than_distance) +
        '&'
    if (json_jump_info !== undefined && json_jump_info !== null)
      url_ += 'json_jump_info=' + encodeURIComponent('' + json_jump_info) + '&'
    if (is_msl !== undefined && is_msl !== null)
      url_ += 'is_msl=' + encodeURIComponent('' + is_msl) + '&'
    if (is_crouch_bind !== undefined && is_crouch_bind !== null)
      url_ += 'is_crouch_bind=' + encodeURIComponent('' + is_crouch_bind) + '&'
    if (is_forward_bind !== undefined && is_forward_bind !== null)
      url_ +=
        'is_forward_bind=' + encodeURIComponent('' + is_forward_bind) + '&'
    if (is_crouch_boost !== undefined && is_crouch_boost !== null)
      url_ +=
        'is_crouch_boost=' + encodeURIComponent('' + is_crouch_boost) + '&'
    if (updated_by_id !== undefined && updated_by_id !== null)
      url_ += 'updated_by_id=' + encodeURIComponent('' + updated_by_id) + '&'
    if (created_since !== undefined && created_since !== null)
      url_ +=
        'created_since=' +
        encodeURIComponent(created_since ? '' + created_since.toJSON() : '') +
        '&'
    if (updated_since !== undefined && updated_since !== null)
      url_ +=
        'updated_since=' +
        encodeURIComponent(updated_since ? '' + updated_since.toJSON() : '') +
        '&'
    if (offset !== undefined && offset !== null)
      url_ += 'offset=' + encodeURIComponent('' + offset) + '&'
    if (limit !== undefined && limit !== null)
      url_ += 'limit=' + encodeURIComponent('' + limit) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {},
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGet2(_response)
      })
  }

  protected processGet2(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      )
    }
    return Promise.resolve<void>(<any>null)
  }

  /**
   * @param record (optional)
   * @param version The requested API version
   * @return Success
   */
  post2(
    record: Jumpstat | null | undefined,
    version: string,
    cancelToken?: CancelToken | undefined
  ): Promise<JumpstatPlace> {
    let url_ = this.baseUrl + '/api/v{version}/jumpstats'
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.")
    url_ = url_.replace('{version}', encodeURIComponent('' + version))
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(record)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processPost2(_response)
      })
  }

  protected processPost2(response: AxiosResponse): Promise<JumpstatPlace> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JumpstatPlace.fromJS(resultData200)
      return result200
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      )
    }
    return Promise.resolve<JumpstatPlace>(<any>null)
  }

  /**
   * @param id (optional)
   * @param server_id (optional)
   * @param steamid64 (optional)
   * @param steam_id (optional)
   * @param jumptype (optional)
   * @param steamid64_list (optional)
   * @param jumptype_list (optional)
   * @param greater_than_distance (optional)
   * @param less_than_distance (optional)
   * @param json_jump_info (optional)
   * @param is_msl (optional)
   * @param is_crouch_bind (optional)
   * @param is_forward_bind (optional)
   * @param is_crouch_boost (optional)
   * @param updated_by_id (optional)
   * @param created_since (optional)
   * @param updated_since (optional)
   * @param offset (optional)
   * @param limit (optional)
   * @param version The requested API version
   * @return Success
   */
  getJumpTopByFilter(
    jump_type: string,
    id: number | null | undefined,
    server_id: number | null | undefined,
    steamid64: number | null | undefined,
    steam_id: string | null | undefined,
    jumptype: string | null | undefined,
    steamid64_list: number[] | null | undefined,
    jumptype_list: number[] | null | undefined,
    greater_than_distance: number | null | undefined,
    less_than_distance: number | null | undefined,
    json_jump_info: string | null | undefined,
    is_msl: boolean | null | undefined,
    is_crouch_bind: boolean | null | undefined,
    is_forward_bind: boolean | null | undefined,
    is_crouch_boost: boolean | null | undefined,
    updated_by_id: number | null | undefined,
    created_since: Date | null | undefined,
    updated_since: Date | null | undefined,
    offset: number | null | undefined,
    limit: number | null | undefined,
    version: string,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + '/api/v{version}/jumpstats/{jump_type}/top?'
    if (jump_type === undefined || jump_type === null)
      throw new Error("The parameter 'jump_type' must be defined.")
    url_ = url_.replace('{jump_type}', encodeURIComponent('' + jump_type))
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.")
    url_ = url_.replace('{version}', encodeURIComponent('' + version))
    if (id !== undefined && id !== null)
      url_ += 'id=' + encodeURIComponent('' + id) + '&'
    if (server_id !== undefined && server_id !== null)
      url_ += 'server_id=' + encodeURIComponent('' + server_id) + '&'
    if (steamid64 !== undefined && steamid64 !== null)
      url_ += 'steamid64=' + encodeURIComponent('' + steamid64) + '&'
    if (steam_id !== undefined && steam_id !== null)
      url_ += 'steam_id=' + encodeURIComponent('' + steam_id) + '&'
    if (jumptype !== undefined && jumptype !== null)
      url_ += 'jumptype=' + encodeURIComponent('' + jumptype) + '&'
    if (steamid64_list !== undefined && steamid64_list !== null)
      steamid64_list &&
        steamid64_list.forEach((item) => {
          url_ += 'steamid64_list=' + encodeURIComponent('' + item) + '&'
        })
    if (jumptype_list !== undefined && jumptype_list !== null)
      jumptype_list &&
        jumptype_list.forEach((item) => {
          url_ += 'jumptype_list=' + encodeURIComponent('' + item) + '&'
        })
    if (greater_than_distance !== undefined && greater_than_distance !== null)
      url_ +=
        'greater_than_distance=' +
        encodeURIComponent('' + greater_than_distance) +
        '&'
    if (less_than_distance !== undefined && less_than_distance !== null)
      url_ +=
        'less_than_distance=' +
        encodeURIComponent('' + less_than_distance) +
        '&'
    if (json_jump_info !== undefined && json_jump_info !== null)
      url_ += 'json_jump_info=' + encodeURIComponent('' + json_jump_info) + '&'
    if (is_msl !== undefined && is_msl !== null)
      url_ += 'is_msl=' + encodeURIComponent('' + is_msl) + '&'
    if (is_crouch_bind !== undefined && is_crouch_bind !== null)
      url_ += 'is_crouch_bind=' + encodeURIComponent('' + is_crouch_bind) + '&'
    if (is_forward_bind !== undefined && is_forward_bind !== null)
      url_ +=
        'is_forward_bind=' + encodeURIComponent('' + is_forward_bind) + '&'
    if (is_crouch_boost !== undefined && is_crouch_boost !== null)
      url_ +=
        'is_crouch_boost=' + encodeURIComponent('' + is_crouch_boost) + '&'
    if (updated_by_id !== undefined && updated_by_id !== null)
      url_ += 'updated_by_id=' + encodeURIComponent('' + updated_by_id) + '&'
    if (created_since !== undefined && created_since !== null)
      url_ +=
        'created_since=' +
        encodeURIComponent(created_since ? '' + created_since.toJSON() : '') +
        '&'
    if (updated_since !== undefined && updated_since !== null)
      url_ +=
        'updated_since=' +
        encodeURIComponent(updated_since ? '' + updated_since.toJSON() : '') +
        '&'
    if (offset !== undefined && offset !== null)
      url_ += 'offset=' + encodeURIComponent('' + offset) + '&'
    if (limit !== undefined && limit !== null)
      url_ += 'limit=' + encodeURIComponent('' + limit) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {},
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetJumpTopByFilter(_response)
      })
  }

  protected processGetJumpTopByFilter(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      )
    }
    return Promise.resolve<void>(<any>null)
  }

  /**
   * @param version The requested API version
   * @return Success
   */
  getJumpTop30(
    jump_type: string,
    version: string,
    cancelToken?: CancelToken | undefined
  ): Promise<Jumpstat_Without_Full_Detail[]> {
    let url_ = this.baseUrl + '/api/v{version}/jumpstats/{jump_type}/top30'
    if (jump_type === undefined || jump_type === null)
      throw new Error("The parameter 'jump_type' must be defined.")
    url_ = url_.replace('{jump_type}', encodeURIComponent('' + jump_type))
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.")
    url_ = url_.replace('{version}', encodeURIComponent('' + version))
    url_ = url_.replace(/[?&]$/, '')

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'application/json',
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetJumpTop30(_response)
      })
  }

  protected processGetJumpTop30(
    response: AxiosResponse
  ): Promise<Jumpstat_Without_Full_Detail[]> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      if (Array.isArray(resultData200)) {
        result200 = [] as any
        for (let item of resultData200)
          result200!.push(Jumpstat_Without_Full_Detail.fromJS(item))
      }
      return result200
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      )
    }
    return Promise.resolve<Jumpstat_Without_Full_Detail[]>(<any>null)
  }

  /**
   * @param id (optional)
   * @param name (optional)
   * @param larger_than_filesize (optional)
   * @param smaller_than_filesize (optional)
   * @param is_validated (optional)
   * @param difficulty (optional)
   * @param created_since (optional)
   * @param updated_since (optional)
   * @param offset (optional)
   * @param limit (optional)
   * @param version The requested API version
   * @return Success
   */
  get3(
    id: number[] | null | undefined,
    name: string | null | undefined,
    larger_than_filesize: number | null | undefined,
    smaller_than_filesize: number | null | undefined,
    is_validated: boolean | null | undefined,
    difficulty: number | null | undefined,
    created_since: Date | null | undefined,
    updated_since: Date | null | undefined,
    offset: number | null | undefined,
    limit: number | null | undefined,
    version: string,
    cancelToken?: CancelToken | undefined
  ): Promise<Map[]> {
    let url_ = this.baseUrl + '/api/v{version}/maps?'
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.")
    url_ = url_.replace('{version}', encodeURIComponent('' + version))
    if (id !== undefined && id !== null)
      id &&
        id.forEach((item) => {
          url_ += 'id=' + encodeURIComponent('' + item) + '&'
        })
    if (name !== undefined && name !== null)
      url_ += 'name=' + encodeURIComponent('' + name) + '&'
    if (larger_than_filesize !== undefined && larger_than_filesize !== null)
      url_ +=
        'larger_than_filesize=' +
        encodeURIComponent('' + larger_than_filesize) +
        '&'
    if (smaller_than_filesize !== undefined && smaller_than_filesize !== null)
      url_ +=
        'smaller_than_filesize=' +
        encodeURIComponent('' + smaller_than_filesize) +
        '&'
    if (is_validated !== undefined && is_validated !== null)
      url_ += 'is_validated=' + encodeURIComponent('' + is_validated) + '&'
    if (difficulty !== undefined && difficulty !== null)
      url_ += 'difficulty=' + encodeURIComponent('' + difficulty) + '&'
    if (created_since !== undefined && created_since !== null)
      url_ +=
        'created_since=' +
        encodeURIComponent(created_since ? '' + created_since.toJSON() : '') +
        '&'
    if (updated_since !== undefined && updated_since !== null)
      url_ +=
        'updated_since=' +
        encodeURIComponent(updated_since ? '' + updated_since.toJSON() : '') +
        '&'
    if (offset !== undefined && offset !== null)
      url_ += 'offset=' + encodeURIComponent('' + offset) + '&'
    if (limit !== undefined && limit !== null)
      url_ += 'limit=' + encodeURIComponent('' + limit) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'application/json',
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGet3(_response)
      })
  }

  protected processGet3(response: AxiosResponse): Promise<Map[]> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      if (Array.isArray(resultData200)) {
        result200 = [] as any
        for (let item of resultData200) result200!.push(Map.fromJS(item))
      }
      return result200
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      )
    }
    return Promise.resolve<Map[]>(<any>null)
  }

  /**
   * @param version The requested API version
   * @return Success
   */
  getById(
    id: number,
    version: string,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + '/api/v{version}/maps/{id}'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{Id}', encodeURIComponent('' + id))
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.")
    url_ = url_.replace('{version}', encodeURIComponent('' + version))
    url_ = url_.replace(/[?&]$/, '')

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {},
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetById(_response)
      })
  }

  protected processGetById(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      )
    }
    return Promise.resolve<void>(<any>null)
  }

  /**
   * @param version The requested API version
   * @return Success
   */
  getByName(
    map_name: string,
    version: string,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + '/api/v{version}/maps/name/{map_name}'
    if (map_name === undefined || map_name === null)
      throw new Error("The parameter 'map_name' must be defined.")
    url_ = url_.replace('{map_name}', encodeURIComponent('' + map_name))
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.")
    url_ = url_.replace('{version}', encodeURIComponent('' + version))
    url_ = url_.replace(/[?&]$/, '')

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {},
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetByName(_response)
      })
  }

  protected processGetByName(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      )
    }
    return Promise.resolve<void>(<any>null)
  }

  /**
   * @param version The requested API version
   * @return Success
   */
  getAll(
    version: string,
    cancelToken?: CancelToken | undefined
  ): Promise<Mode[]> {
    let url_ = this.baseUrl + '/api/v{version}/modes'
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.")
    url_ = url_.replace('{version}', encodeURIComponent('' + version))
    url_ = url_.replace(/[?&]$/, '')

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'application/json',
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetAll(_response)
      })
  }

  protected processGetAll(response: AxiosResponse): Promise<Mode[]> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      if (Array.isArray(resultData200)) {
        result200 = [] as any
        for (let item of resultData200) result200!.push(Mode.fromJS(item))
      }
      return result200
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      )
    }
    return Promise.resolve<Mode[]>(<any>null)
  }

  /**
   * @param version The requested API version
   * @return Success
   */
  getModeByName(
    mode_name: string,
    version: string,
    cancelToken?: CancelToken | undefined
  ): Promise<Mode> {
    let url_ = this.baseUrl + '/api/v{version}/modes/name/{mode_name}'
    if (mode_name === undefined || mode_name === null)
      throw new Error("The parameter 'mode_name' must be defined.")
    url_ = url_.replace('{mode_name}', encodeURIComponent('' + mode_name))
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.")
    url_ = url_.replace('{version}', encodeURIComponent('' + version))
    url_ = url_.replace(/[?&]$/, '')

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'application/json',
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetModeByName(_response)
      })
  }

  protected processGetModeByName(response: AxiosResponse): Promise<Mode> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = Mode.fromJS(resultData200)
      return result200
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      )
    }
    return Promise.resolve<Mode>(<any>null)
  }

  /**
   * @param version The requested API version
   * @return Success
   */
  getModeByID(
    id: number,
    version: string,
    cancelToken?: CancelToken | undefined
  ): Promise<Mode> {
    let url_ = this.baseUrl + '/api/v{version}/modes/id/{id}'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{id}', encodeURIComponent('' + id))
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.")
    url_ = url_.replace('{version}', encodeURIComponent('' + version))
    url_ = url_.replace(/[?&]$/, '')

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'application/json',
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetModeByID(_response)
      })
  }

  protected processGetModeByID(response: AxiosResponse): Promise<Mode> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = Mode.fromJS(resultData200)
      return result200
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      )
    }
    return Promise.resolve<Mode>(<any>null)
  }

  /**
   * @param points_greater_than (optional)
   * @param average_greater_than (optional)
   * @param rating_greater_than (optional)
   * @param finishes_greater_than (optional)
   * @param steamid64s (optional)
   * @param record_filter_ids (optional)
   * @param map_ids (optional)
   * @param stages (optional)
   * @param mode_ids (optional)
   * @param tickrates (optional)
   * @param has_teleports (optional)
   * @param mapTag (optional)
   * @param offset (optional)
   * @param limit (optional)
   * @param version The requested API version
   * @return Success
   */
  getPlayerRanksByParams(
    points_greater_than: number | null | undefined,
    average_greater_than: number | null | undefined,
    rating_greater_than: number | null | undefined,
    finishes_greater_than: number | null | undefined,
    steamid64s: number[] | null | undefined,
    record_filter_ids: number[] | null | undefined,
    map_ids: number[] | null | undefined,
    stages: number[] | null | undefined,
    mode_ids: number[] | null | undefined,
    tickrates: number[] | null | undefined,
    has_teleports: boolean | null | undefined,
    mapTag: string | null | undefined,
    offset: number | null | undefined,
    limit: number | null | undefined,
    version: string,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + '/api/v{version}/player_ranks?'
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.")
    url_ = url_.replace('{version}', encodeURIComponent('' + version))
    if (points_greater_than !== undefined && points_greater_than !== null)
      url_ +=
        'points_greater_than=' +
        encodeURIComponent('' + points_greater_than) +
        '&'
    if (average_greater_than !== undefined && average_greater_than !== null)
      url_ +=
        'average_greater_than=' +
        encodeURIComponent('' + average_greater_than) +
        '&'
    if (rating_greater_than !== undefined && rating_greater_than !== null)
      url_ +=
        'rating_greater_than=' +
        encodeURIComponent('' + rating_greater_than) +
        '&'
    if (finishes_greater_than !== undefined && finishes_greater_than !== null)
      url_ +=
        'finishes_greater_than=' +
        encodeURIComponent('' + finishes_greater_than) +
        '&'
    if (steamid64s !== undefined && steamid64s !== null)
      steamid64s &&
        steamid64s.forEach((item) => {
          url_ += 'steamid64s=' + encodeURIComponent('' + item) + '&'
        })
    if (record_filter_ids !== undefined && record_filter_ids !== null)
      record_filter_ids &&
        record_filter_ids.forEach((item) => {
          url_ += 'record_filter_ids=' + encodeURIComponent('' + item) + '&'
        })
    if (map_ids !== undefined && map_ids !== null)
      map_ids &&
        map_ids.forEach((item) => {
          url_ += 'map_ids=' + encodeURIComponent('' + item) + '&'
        })
    if (stages !== undefined && stages !== null)
      stages &&
        stages.forEach((item) => {
          url_ += 'stages=' + encodeURIComponent('' + item) + '&'
        })
    if (mode_ids !== undefined && mode_ids !== null)
      mode_ids &&
        mode_ids.forEach((item) => {
          url_ += 'mode_ids=' + encodeURIComponent('' + item) + '&'
        })
    if (tickrates !== undefined && tickrates !== null)
      tickrates &&
        tickrates.forEach((item) => {
          url_ += 'tickrates=' + encodeURIComponent('' + item) + '&'
        })
    if (has_teleports !== undefined && has_teleports !== null)
      url_ += 'has_teleports=' + encodeURIComponent('' + has_teleports) + '&'
    if (mapTag !== undefined && mapTag !== null)
      url_ += 'mapTag=' + encodeURIComponent('' + mapTag) + '&'
    if (offset !== undefined && offset !== null)
      url_ += 'offset=' + encodeURIComponent('' + offset) + '&'
    if (limit !== undefined && limit !== null)
      url_ += 'limit=' + encodeURIComponent('' + limit) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {},
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetPlayerRanksByParams(_response)
      })
  }

  protected processGetPlayerRanksByParams(
    response: AxiosResponse
  ): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      )
    }
    return Promise.resolve<void>(<any>null)
  }

  /**
   * @param name (optional)
   * @param steam_id (optional)
   * @param is_banned (optional)
   * @param total_records (optional)
   * @param ip (optional)
   * @param steamid64_list (optional)
   * @param offset (optional)
   * @param limit (optional)
   * @param version The requested API version
   * @return Success
   */
  get4(
    name: string | null | undefined,
    steam_id: string | null | undefined,
    is_banned: boolean | null | undefined,
    total_records: number | null | undefined,
    ip: string | null | undefined,
    steamid64_list: number[] | null | undefined,
    offset: number | null | undefined,
    limit: number | null | undefined,
    version: string,
    cancelToken?: CancelToken | undefined
  ): Promise<Player[]> {
    let url_ = this.baseUrl + '/api/v{version}/players?'
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.")
    url_ = url_.replace('{version}', encodeURIComponent('' + version))
    if (name !== undefined && name !== null)
      url_ += 'name=' + encodeURIComponent('' + name) + '&'
    if (steam_id !== undefined && steam_id !== null)
      url_ += 'steam_id=' + encodeURIComponent('' + steam_id) + '&'
    if (is_banned !== undefined && is_banned !== null)
      url_ += 'is_banned=' + encodeURIComponent('' + is_banned) + '&'
    if (total_records !== undefined && total_records !== null)
      url_ += 'total_records=' + encodeURIComponent('' + total_records) + '&'
    if (ip !== undefined && ip !== null)
      url_ += 'ip=' + encodeURIComponent('' + ip) + '&'
    if (steamid64_list !== undefined && steamid64_list !== null)
      steamid64_list &&
        steamid64_list.forEach((item) => {
          url_ += 'steamid64_list=' + encodeURIComponent('' + item) + '&'
        })
    if (offset !== undefined && offset !== null)
      url_ += 'offset=' + encodeURIComponent('' + offset) + '&'
    if (limit !== undefined && limit !== null)
      url_ += 'limit=' + encodeURIComponent('' + limit) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'application/json',
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGet4(_response)
      })
  }

  protected processGet4(response: AxiosResponse): Promise<Player[]> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      if (Array.isArray(resultData200)) {
        result200 = [] as any
        for (let item of resultData200) result200!.push(Player.fromJS(item))
      }
      return result200
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      )
    }
    return Promise.resolve<Player[]>(<any>null)
  }

  /**
   * @param version The requested API version
   * @return Success
   */
  getPlayerssBySteamID(
    steamid: string,
    version: string,
    cancelToken?: CancelToken | undefined
  ): Promise<Player[]> {
    let url_ = this.baseUrl + '/api/v{version}/players/steamid/{steamid}'
    if (steamid === undefined || steamid === null)
      throw new Error("The parameter 'steamid' must be defined.")
    url_ = url_.replace('{steamid}', encodeURIComponent('' + steamid))
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.")
    url_ = url_.replace('{version}', encodeURIComponent('' + version))
    url_ = url_.replace(/[?&]$/, '')

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'application/json',
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetPlayerssBySteamID(_response)
      })
  }

  protected processGetPlayerssBySteamID(
    response: AxiosResponse
  ): Promise<Player[]> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      if (Array.isArray(resultData200)) {
        result200 = [] as any
        for (let item of resultData200) result200!.push(Player.fromJS(item))
      }
      return result200
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      )
    }
    return Promise.resolve<Player[]>(<any>null)
  }

  /**
   * @param version The requested API version
   * @return Success
   */
  getPlayerssBySteamIDAndIP(
    steamid: string,
    ip: string,
    version: string,
    cancelToken?: CancelToken | undefined
  ): Promise<Player> {
    let url_ =
      this.baseUrl + '/api/v{version}/players/steamid/{steamid}/ip/{ip}'
    if (steamid === undefined || steamid === null)
      throw new Error("The parameter 'steamid' must be defined.")
    url_ = url_.replace('{steamid}', encodeURIComponent('' + steamid))
    if (ip === undefined || ip === null)
      throw new Error("The parameter 'ip' must be defined.")
    url_ = url_.replace('{ip}', encodeURIComponent('' + ip))
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.")
    url_ = url_.replace('{version}', encodeURIComponent('' + version))
    url_ = url_.replace(/[?&]$/, '')

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'application/json',
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetPlayerssBySteamIDAndIP(_response)
      })
  }

  protected processGetPlayerssBySteamIDAndIP(
    response: AxiosResponse
  ): Promise<Player> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = Player.fromJS(resultData200)
      return result200
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      )
    }
    return Promise.resolve<Player>(<any>null)
  }

  /**
   * @param version The requested API version
   * @return Success
   */
  getPlayersAlts(
    steamid: string,
    version: string,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + '/api/v{version}/players/steamid/{steamid}/alts'
    if (steamid === undefined || steamid === null)
      throw new Error("The parameter 'steamid' must be defined.")
    url_ = url_.replace('{steamid}', encodeURIComponent('' + steamid))
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.")
    url_ = url_.replace('{version}', encodeURIComponent('' + version))
    url_ = url_.replace(/[?&]$/, '')

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {},
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetPlayersAlts(_response)
      })
  }

  protected processGetPlayersAlts(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      )
    }
    return Promise.resolve<void>(<any>null)
  }

  /**
   * @param steamids (optional)
   * @param version The requested API version
   * @return Success
   */
  getBannedPlayersBySteamIDs(
    steamids: string | null | undefined,
    version: string,
    cancelToken?: CancelToken | undefined
  ): Promise<Player[]> {
    let url_ =
      this.baseUrl + '/api/v{version}/players/get_banned_players/steamid?'
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.")
    url_ = url_.replace('{version}', encodeURIComponent('' + version))
    if (steamids !== undefined && steamids !== null)
      url_ += 'steamids=' + encodeURIComponent('' + steamids) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'application/json',
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetBannedPlayersBySteamIDs(_response)
      })
  }

  protected processGetBannedPlayersBySteamIDs(
    response: AxiosResponse
  ): Promise<Player[]> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      if (Array.isArray(resultData200)) {
        result200 = [] as any
        for (let item of resultData200) result200!.push(Player.fromJS(item))
      }
      return result200
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      )
    }
    return Promise.resolve<Player[]>(<any>null)
  }

  /**
   * @param ids (optional)
   * @param map_ids (optional)
   * @param stages (optional)
   * @param mode_ids (optional)
   * @param tickrates (optional)
   * @param has_teleports (optional)
   * @param offset (optional)
   * @param limit (optional)
   * @param version The requested API version
   * @return Success
   */
  getRecordFiltersByParams(
    ids: number[] | null | undefined,
    map_ids: number[] | null | undefined,
    stages: number[] | null | undefined,
    mode_ids: number[] | null | undefined,
    tickrates: number[] | null | undefined,
    has_teleports: boolean | null | undefined,
    offset: number | null | undefined,
    limit: number | null | undefined,
    version: string,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + '/api/v{version}/record_filters?'
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.")
    url_ = url_.replace('{version}', encodeURIComponent('' + version))
    if (ids !== undefined && ids !== null)
      ids &&
        ids.forEach((item) => {
          url_ += 'ids=' + encodeURIComponent('' + item) + '&'
        })
    if (map_ids !== undefined && map_ids !== null)
      map_ids &&
        map_ids.forEach((item) => {
          url_ += 'map_ids=' + encodeURIComponent('' + item) + '&'
        })
    if (stages !== undefined && stages !== null)
      stages &&
        stages.forEach((item) => {
          url_ += 'stages=' + encodeURIComponent('' + item) + '&'
        })
    if (mode_ids !== undefined && mode_ids !== null)
      mode_ids &&
        mode_ids.forEach((item) => {
          url_ += 'mode_ids=' + encodeURIComponent('' + item) + '&'
        })
    if (tickrates !== undefined && tickrates !== null)
      tickrates &&
        tickrates.forEach((item) => {
          url_ += 'tickrates=' + encodeURIComponent('' + item) + '&'
        })
    if (has_teleports !== undefined && has_teleports !== null)
      url_ += 'has_teleports=' + encodeURIComponent('' + has_teleports) + '&'
    if (offset !== undefined && offset !== null)
      url_ += 'offset=' + encodeURIComponent('' + offset) + '&'
    if (limit !== undefined && limit !== null)
      url_ += 'limit=' + encodeURIComponent('' + limit) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {},
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetRecordFiltersByParams(_response)
      })
  }

  protected processGetRecordFiltersByParams(
    response: AxiosResponse
  ): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      )
    }
    return Promise.resolve<void>(<any>null)
  }

  /**
   * @param ids (optional)
   * @param map_ids (optional)
   * @param stages (optional)
   * @param mode_ids (optional)
   * @param tickrates (optional)
   * @param has_teleports (optional)
   * @param offset (optional)
   * @param limit (optional)
   * @param version The requested API version
   * @return Success
   */
  getRankDistributionsByParams(
    ids: number[] | null | undefined,
    map_ids: number[] | null | undefined,
    stages: number[] | null | undefined,
    mode_ids: number[] | null | undefined,
    tickrates: number[] | null | undefined,
    has_teleports: boolean | null | undefined,
    offset: number | null | undefined,
    limit: number | null | undefined,
    version: string,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + '/api/v{version}/record_filters/distributions?'
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.")
    url_ = url_.replace('{version}', encodeURIComponent('' + version))
    if (ids !== undefined && ids !== null)
      ids &&
        ids.forEach((item) => {
          url_ += 'ids=' + encodeURIComponent('' + item) + '&'
        })
    if (map_ids !== undefined && map_ids !== null)
      map_ids &&
        map_ids.forEach((item) => {
          url_ += 'map_ids=' + encodeURIComponent('' + item) + '&'
        })
    if (stages !== undefined && stages !== null)
      stages &&
        stages.forEach((item) => {
          url_ += 'stages=' + encodeURIComponent('' + item) + '&'
        })
    if (mode_ids !== undefined && mode_ids !== null)
      mode_ids &&
        mode_ids.forEach((item) => {
          url_ += 'mode_ids=' + encodeURIComponent('' + item) + '&'
        })
    if (tickrates !== undefined && tickrates !== null)
      tickrates &&
        tickrates.forEach((item) => {
          url_ += 'tickrates=' + encodeURIComponent('' + item) + '&'
        })
    if (has_teleports !== undefined && has_teleports !== null)
      url_ += 'has_teleports=' + encodeURIComponent('' + has_teleports) + '&'
    if (offset !== undefined && offset !== null)
      url_ += 'offset=' + encodeURIComponent('' + offset) + '&'
    if (limit !== undefined && limit !== null)
      url_ += 'limit=' + encodeURIComponent('' + limit) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {},
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetRankDistributionsByParams(_response)
      })
  }

  protected processGetRankDistributionsByParams(
    response: AxiosResponse
  ): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      )
    }
    return Promise.resolve<void>(<any>null)
  }

  /**
   * @param version The requested API version
   * @return Success
   */
  getRecordPlaceById(
    id: number,
    version: string,
    cancelToken?: CancelToken | undefined
  ): Promise<number> {
    let url_ = this.baseUrl + '/api/v{version}/records/place/{id}'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{id}', encodeURIComponent('' + id))
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.")
    url_ = url_.replace('{version}', encodeURIComponent('' + version))
    url_ = url_.replace(/[?&]$/, '')

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'application/json',
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetRecordPlaceById(_response)
      })
  }

  protected processGetRecordPlaceById(
    response: AxiosResponse
  ): Promise<number> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = resultData200 !== undefined ? resultData200 : <any>null
      return result200
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      )
    }
    return Promise.resolve<number>(<any>null)
  }

  /**
   * @param steam_id (optional)
   * @param steamid64 (optional)
   * @param map_id (optional)
   * @param map_name (optional)
   * @param tickrate (optional)
   * @param overall (optional)
   * @param stage (optional)
   * @param modes_list_string (optional)
   * @param modes_list (optional)
   * @param has_teleports (optional)
   * @param player_name (optional)
   * @param offset (optional)
   * @param limit (optional)
   * @param version The requested API version
   * @return Success
   */
  getRecordTopByParams(
    steam_id: string | null | undefined,
    steamid64: number | null | undefined,
    map_id: number | null | undefined,
    map_name: string | null | undefined,
    tickrate: number | null | undefined,
    overall: boolean | null | undefined,
    stage: number | null | undefined,
    modes_list_string: string | null | undefined,
    modes_list: string[] | null | undefined,
    has_teleports: boolean | null | undefined,
    player_name: string | null | undefined,
    offset: number | null | undefined,
    limit: number | null | undefined,
    version: string,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + '/api/v{version}/records/top?'
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.")
    url_ = url_.replace('{version}', encodeURIComponent('' + version))
    if (steam_id !== undefined && steam_id !== null)
      url_ += 'steam_id=' + encodeURIComponent('' + steam_id) + '&'
    if (steamid64 !== undefined && steamid64 !== null)
      url_ += 'steamid64=' + encodeURIComponent('' + steamid64) + '&'
    if (map_id !== undefined && map_id !== null)
      url_ += 'map_id=' + encodeURIComponent('' + map_id) + '&'
    if (map_name !== undefined && map_name !== null)
      url_ += 'map_name=' + encodeURIComponent('' + map_name) + '&'
    if (tickrate !== undefined && tickrate !== null)
      url_ += 'tickrate=' + encodeURIComponent('' + tickrate) + '&'
    if (overall !== undefined && overall !== null)
      url_ += 'overall=' + encodeURIComponent('' + overall) + '&'
    if (stage !== undefined && stage !== null)
      url_ += 'stage=' + encodeURIComponent('' + stage) + '&'
    if (modes_list_string !== undefined && modes_list_string !== null)
      url_ +=
        'modes_list_string=' + encodeURIComponent('' + modes_list_string) + '&'
    if (modes_list !== undefined && modes_list !== null)
      modes_list &&
        modes_list.forEach((item) => {
          url_ += 'modes_list=' + encodeURIComponent('' + item) + '&'
        })
    if (has_teleports !== undefined && has_teleports !== null)
      url_ += 'has_teleports=' + encodeURIComponent('' + has_teleports) + '&'
    if (player_name !== undefined && player_name !== null)
      url_ += 'player_name=' + encodeURIComponent('' + player_name) + '&'
    if (offset !== undefined && offset !== null)
      url_ += 'offset=' + encodeURIComponent('' + offset) + '&'
    if (limit !== undefined && limit !== null)
      url_ += 'limit=' + encodeURIComponent('' + limit) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {},
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetRecordTopByParams(_response)
      })
  }

  protected processGetRecordTopByParams(
    response: AxiosResponse
  ): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      )
    }
    return Promise.resolve<void>(<any>null)
  }

  /**
   * @param ids (optional)
   * @param map_ids (optional)
   * @param stages (optional)
   * @param mode_ids (optional)
   * @param tickrates (optional)
   * @param has_teleports (optional)
   * @param mapTag (optional)
   * @param offset (optional)
   * @param limit (optional)
   * @param version The requested API version
   * @return Success
   */
  getWorldRecordsByParams(
    ids: number[] | null | undefined,
    map_ids: number[] | null | undefined,
    stages: number[] | null | undefined,
    mode_ids: number[] | null | undefined,
    tickrates: number[] | null | undefined,
    has_teleports: boolean | null | undefined,
    mapTag: string | null | undefined,
    offset: number | null | undefined,
    limit: number | null | undefined,
    version: string,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + '/api/v{version}/records/top/world_records?'
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.")
    url_ = url_.replace('{version}', encodeURIComponent('' + version))
    if (ids !== undefined && ids !== null)
      ids &&
        ids.forEach((item) => {
          url_ += 'ids=' + encodeURIComponent('' + item) + '&'
        })
    if (map_ids !== undefined && map_ids !== null)
      map_ids &&
        map_ids.forEach((item) => {
          url_ += 'map_ids=' + encodeURIComponent('' + item) + '&'
        })
    if (stages !== undefined && stages !== null)
      stages &&
        stages.forEach((item) => {
          url_ += 'stages=' + encodeURIComponent('' + item) + '&'
        })
    if (mode_ids !== undefined && mode_ids !== null)
      mode_ids &&
        mode_ids.forEach((item) => {
          url_ += 'mode_ids=' + encodeURIComponent('' + item) + '&'
        })
    if (tickrates !== undefined && tickrates !== null)
      tickrates &&
        tickrates.forEach((item) => {
          url_ += 'tickrates=' + encodeURIComponent('' + item) + '&'
        })
    if (has_teleports !== undefined && has_teleports !== null)
      url_ += 'has_teleports=' + encodeURIComponent('' + has_teleports) + '&'
    if (mapTag !== undefined && mapTag !== null)
      url_ += 'mapTag=' + encodeURIComponent('' + mapTag) + '&'
    if (offset !== undefined && offset !== null)
      url_ += 'offset=' + encodeURIComponent('' + offset) + '&'
    if (limit !== undefined && limit !== null)
      url_ += 'limit=' + encodeURIComponent('' + limit) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {},
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetWorldRecordsByParams(_response)
      })
  }

  protected processGetWorldRecordsByParams(
    response: AxiosResponse
  ): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      )
    }
    return Promise.resolve<void>(<any>null)
  }

  /**
   * @param steam_id (optional)
   * @param steamid64 (optional)
   * @param map_id (optional)
   * @param map_name (optional)
   * @param has_teleports (optional)
   * @param tickrate (optional)
   * @param stage (optional)
   * @param modes_list_string (optional)
   * @param modes_list (optional)
   * @param place_top_at_least (optional)
   * @param place_top_overall_at_least (optional)
   * @param created_since (optional)
   * @param offset (optional)
   * @param limit (optional)
   * @param version The requested API version
   * @return Success
   */
  getRecentRecordTopByParams(
    steam_id: string | null | undefined,
    steamid64: number | null | undefined,
    map_id: number | null | undefined,
    map_name: string | null | undefined,
    has_teleports: boolean | null | undefined,
    tickrate: number | null | undefined,
    stage: number | null | undefined,
    modes_list_string: string | null | undefined,
    modes_list: string[] | null | undefined,
    place_top_at_least: number | null | undefined,
    place_top_overall_at_least: number | null | undefined,
    created_since: Date | null | undefined,
    offset: number | null | undefined,
    limit: number | null | undefined,
    version: string,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + '/api/v{version}/records/top/recent?'
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.")
    url_ = url_.replace('{version}', encodeURIComponent('' + version))
    if (steam_id !== undefined && steam_id !== null)
      url_ += 'steam_id=' + encodeURIComponent('' + steam_id) + '&'
    if (steamid64 !== undefined && steamid64 !== null)
      url_ += 'steamid64=' + encodeURIComponent('' + steamid64) + '&'
    if (map_id !== undefined && map_id !== null)
      url_ += 'map_id=' + encodeURIComponent('' + map_id) + '&'
    if (map_name !== undefined && map_name !== null)
      url_ += 'map_name=' + encodeURIComponent('' + map_name) + '&'
    if (has_teleports !== undefined && has_teleports !== null)
      url_ += 'has_teleports=' + encodeURIComponent('' + has_teleports) + '&'
    if (tickrate !== undefined && tickrate !== null)
      url_ += 'tickrate=' + encodeURIComponent('' + tickrate) + '&'
    if (stage !== undefined && stage !== null)
      url_ += 'stage=' + encodeURIComponent('' + stage) + '&'
    if (modes_list_string !== undefined && modes_list_string !== null)
      url_ +=
        'modes_list_string=' + encodeURIComponent('' + modes_list_string) + '&'
    if (modes_list !== undefined && modes_list !== null)
      modes_list &&
        modes_list.forEach((item) => {
          url_ += 'modes_list=' + encodeURIComponent('' + item) + '&'
        })
    if (place_top_at_least !== undefined && place_top_at_least !== null)
      url_ +=
        'place_top_at_least=' +
        encodeURIComponent('' + place_top_at_least) +
        '&'
    if (
      place_top_overall_at_least !== undefined &&
      place_top_overall_at_least !== null
    )
      url_ +=
        'place_top_overall_at_least=' +
        encodeURIComponent('' + place_top_overall_at_least) +
        '&'
    if (created_since !== undefined && created_since !== null)
      url_ +=
        'created_since=' +
        encodeURIComponent(created_since ? '' + created_since.toJSON() : '') +
        '&'
    if (offset !== undefined && offset !== null)
      url_ += 'offset=' + encodeURIComponent('' + offset) + '&'
    if (limit !== undefined && limit !== null)
      url_ += 'limit=' + encodeURIComponent('' + limit) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {},
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetRecentRecordTopByParams(_response)
      })
  }

  protected processGetRecentRecordTopByParams(
    response: AxiosResponse
  ): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      )
    }
    return Promise.resolve<void>(<any>null)
  }

  /**
   * @param recordCreateView (optional)
   * @param version The requested API version
   * @return Success
   */
  post3(
    recordCreateView: RecordCreateView | null | undefined,
    version: string,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + '/api/v{version}/records'
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.")
    url_ = url_.replace('{version}', encodeURIComponent('' + version))
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(recordCreateView)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processPost3(_response)
      })
  }

  protected processPost3(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      )
    }
    return Promise.resolve<void>(<any>null)
  }

  /**
   * @param ids (optional)
   * @param map_ids (optional)
   * @param stages (optional)
   * @param mode_ids (optional)
   * @param tickrates (optional)
   * @param has_teleports (optional)
   * @param offset (optional)
   * @param limit (optional)
   * @param version The requested API version
   * @return Success
   */
  getRecordFilterByParameters(
    ids: number[] | null | undefined,
    map_ids: number[] | null | undefined,
    stages: number[] | null | undefined,
    mode_ids: number[] | null | undefined,
    tickrates: number[] | null | undefined,
    has_teleports: boolean | null | undefined,
    offset: number | null | undefined,
    limit: number | null | undefined,
    version: string,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + '/api/v{version}/records/record_filter?'
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.")
    url_ = url_.replace('{version}', encodeURIComponent('' + version))
    if (ids !== undefined && ids !== null)
      ids &&
        ids.forEach((item) => {
          url_ += 'ids=' + encodeURIComponent('' + item) + '&'
        })
    if (map_ids !== undefined && map_ids !== null)
      map_ids &&
        map_ids.forEach((item) => {
          url_ += 'map_ids=' + encodeURIComponent('' + item) + '&'
        })
    if (stages !== undefined && stages !== null)
      stages &&
        stages.forEach((item) => {
          url_ += 'stages=' + encodeURIComponent('' + item) + '&'
        })
    if (mode_ids !== undefined && mode_ids !== null)
      mode_ids &&
        mode_ids.forEach((item) => {
          url_ += 'mode_ids=' + encodeURIComponent('' + item) + '&'
        })
    if (tickrates !== undefined && tickrates !== null)
      tickrates &&
        tickrates.forEach((item) => {
          url_ += 'tickrates=' + encodeURIComponent('' + item) + '&'
        })
    if (has_teleports !== undefined && has_teleports !== null)
      url_ += 'has_teleports=' + encodeURIComponent('' + has_teleports) + '&'
    if (offset !== undefined && offset !== null)
      url_ += 'offset=' + encodeURIComponent('' + offset) + '&'
    if (limit !== undefined && limit !== null)
      url_ += 'limit=' + encodeURIComponent('' + limit) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {},
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetRecordFilterByParameters(_response)
      })
  }

  protected processGetRecordFilterByParameters(
    response: AxiosResponse
  ): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      )
    }
    return Promise.resolve<void>(<any>null)
  }

  /**
   * @param version The requested API version
   * @return Success
   */
  getByRecordId(
    record_id: number,
    version: string,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + '/api/v{version}/records/{record_id}/replay'
    if (record_id === undefined || record_id === null)
      throw new Error("The parameter 'record_id' must be defined.")
    url_ = url_.replace('{record_id}', encodeURIComponent('' + record_id))
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.")
    url_ = url_.replace('{version}', encodeURIComponent('' + version))
    url_ = url_.replace(/[?&]$/, '')

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {},
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetByRecordId(_response)
      })
  }

  protected processGetByRecordId(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      )
    }
    return Promise.resolve<void>(<any>null)
  }

  /**
   * @param replay (optional)
   * @param version The requested API version
   * @return Success
   */
  submitReplay(
    record_id: number,
    replay: string | null | undefined,
    version: string,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + '/api/v{version}/records/{record_id}/replay'
    if (record_id === undefined || record_id === null)
      throw new Error("The parameter 'record_id' must be defined.")
    url_ = url_.replace('{record_id}', encodeURIComponent('' + record_id))
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.")
    url_ = url_.replace('{version}', encodeURIComponent('' + version))
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(replay)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processSubmitReplay(_response)
      })
  }

  protected processSubmitReplay(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      )
    }
    return Promise.resolve<void>(<any>null)
  }

  /**
   * @param version The requested API version
   * @return Success
   */
  getByReplayId(
    replay_id: number,
    version: string,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + '/api/v{version}/records/replay/{replay_id}'
    if (replay_id === undefined || replay_id === null)
      throw new Error("The parameter 'replay_id' must be defined.")
    url_ = url_.replace('{replay_id}', encodeURIComponent('' + replay_id))
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.")
    url_ = url_.replace('{version}', encodeURIComponent('' + version))
    url_ = url_.replace(/[?&]$/, '')

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {},
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetByReplayId(_response)
      })
  }

  protected processGetByReplayId(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      )
    }
    return Promise.resolve<void>(<any>null)
  }

  /**
   * @param offset (optional)
   * @param limit (optional)
   * @param version The requested API version
   * @return Success
   */
  getReplayList(
    offset: number | null | undefined,
    limit: number | null | undefined,
    version: string,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + '/api/v{version}/records/replay/list?'
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.")
    url_ = url_.replace('{version}', encodeURIComponent('' + version))
    if (offset !== undefined && offset !== null)
      url_ += 'offset=' + encodeURIComponent('' + offset) + '&'
    if (limit !== undefined && limit !== null)
      url_ += 'limit=' + encodeURIComponent('' + limit) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {},
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetReplayList(_response)
      })
  }

  protected processGetReplayList(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      )
    }
    return Promise.resolve<void>(<any>null)
  }

  /**
   * @param id (optional)
   * @param port (optional)
   * @param ip (optional)
   * @param name (optional)
   * @param owner_steamid64 (optional)
   * @param approval_status (optional)
   * @param offset (optional)
   * @param limit (optional)
   * @param version The requested API version
   * @return Success
   */
  get5(
    id: number[] | null | undefined,
    port: number | null | undefined,
    ip: string | null | undefined,
    name: string | null | undefined,
    owner_steamid64: number | null | undefined,
    approval_status: number | null | undefined,
    offset: number | null | undefined,
    limit: number | null | undefined,
    version: string,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + '/api/v{version}/servers?'
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.")
    url_ = url_.replace('{version}', encodeURIComponent('' + version))
    if (id !== undefined && id !== null)
      id &&
        id.forEach((item) => {
          url_ += 'id=' + encodeURIComponent('' + item) + '&'
        })
    if (port !== undefined && port !== null)
      url_ += 'port=' + encodeURIComponent('' + port) + '&'
    if (ip !== undefined && ip !== null)
      url_ += 'ip=' + encodeURIComponent('' + ip) + '&'
    if (name !== undefined && name !== null)
      url_ += 'name=' + encodeURIComponent('' + name) + '&'
    if (owner_steamid64 !== undefined && owner_steamid64 !== null)
      url_ +=
        'owner_steamid64=' + encodeURIComponent('' + owner_steamid64) + '&'
    if (approval_status !== undefined && approval_status !== null)
      url_ +=
        'approval_status=' + encodeURIComponent('' + approval_status) + '&'
    if (offset !== undefined && offset !== null)
      url_ += 'offset=' + encodeURIComponent('' + offset) + '&'
    if (limit !== undefined && limit !== null)
      url_ += 'limit=' + encodeURIComponent('' + limit) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {},
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGet5(_response)
      })
  }

  protected processGet5(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      )
    }
    return Promise.resolve<void>(<any>null)
  }

  /**
   * @param version The requested API version
   * @return Success
   */
  getServersById(
    id: number,
    version: string,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + '/api/v{version}/servers/{id}'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{Id}', encodeURIComponent('' + id))
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.")
    url_ = url_.replace('{version}', encodeURIComponent('' + version))
    url_ = url_.replace(/[?&]$/, '')

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {},
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetServersById(_response)
      })
  }

  protected processGetServersById(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      )
    }
    return Promise.resolve<void>(<any>null)
  }

  /**
   * @param version The requested API version
   * @return Success
   */
  getServersByName(
    server_name: string,
    version: string,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + '/api/v{version}/servers/name/{server_name}'
    if (server_name === undefined || server_name === null)
      throw new Error("The parameter 'server_name' must be defined.")
    url_ = url_.replace('{server_name}', encodeURIComponent('' + server_name))
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.")
    url_ = url_.replace('{version}', encodeURIComponent('' + version))
    url_ = url_.replace(/[?&]$/, '')

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {},
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetServersByName(_response)
      })
  }

  protected processGetServersByName(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      )
    }
    return Promise.resolve<void>(<any>null)
  }

  /**
   * @param serverDTO (optional)
   * @param version The requested API version
   * @return Success
   */
  applyServer(
    serverDTO: ServerCreateDTO | null | undefined,
    version: string,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + '/api/v{version}/servers/apply'
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.")
    url_ = url_.replace('{version}', encodeURIComponent('' + version))
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(serverDTO)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processApplyServer(_response)
      })
  }

  protected processApplyServer(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      )
    }
    return Promise.resolve<void>(<any>null)
  }

  /**
   * @param offset (optional)
   * @param limit (optional)
   * @param version The requested API version
   * @return Success
   */
  get6(
    offset: number | null | undefined,
    limit: number | null | undefined,
    version: string,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + '/api/v{version}/servers/owned?'
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.")
    url_ = url_.replace('{version}', encodeURIComponent('' + version))
    if (offset !== undefined && offset !== null)
      url_ += 'offset=' + encodeURIComponent('' + offset) + '&'
    if (limit !== undefined && limit !== null)
      url_ += 'limit=' + encodeURIComponent('' + limit) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {},
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGet6(_response)
      })
  }

  protected processGet6(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      )
    }
    return Promise.resolve<void>(<any>null)
  }
}

export class Ban_Public implements IBan_Public {
  id?: number | undefined
  ban_type!: string
  expires_on?: Date | undefined
  steamid64?: number | undefined
  player_name?: string | undefined
  steam_id?: string | undefined
  notes?: string | undefined
  stats?: string | undefined
  server_id?: number | undefined
  updated_by_id?: number | undefined
  created_on?: Date | undefined
  updated_on?: Date | undefined

  constructor(data?: IBan_Public) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.ban_type = _data['ban_type']
      this.expires_on = _data['expires_on']
        ? new Date(_data['expires_on'].toString())
        : <any>undefined
      this.steamid64 = _data['steamid64']
      this.player_name = _data['player_name']
      this.steam_id = _data['steam_id']
      this.notes = _data['notes']
      this.stats = _data['stats']
      this.server_id = _data['server_id']
      this.updated_by_id = _data['updated_by_id']
      this.created_on = _data['created_on']
        ? new Date(_data['created_on'].toString())
        : <any>undefined
      this.updated_on = _data['updated_on']
        ? new Date(_data['updated_on'].toString())
        : <any>undefined
    }
  }

  static fromJS(data: any): Ban_Public {
    data = typeof data === 'object' ? data : {}
    let result = new Ban_Public()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['ban_type'] = this.ban_type
    data['expires_on'] = this.expires_on
      ? this.expires_on.toISOString()
      : <any>undefined
    data['steamid64'] = this.steamid64
    data['player_name'] = this.player_name
    data['steam_id'] = this.steam_id
    data['notes'] = this.notes
    data['stats'] = this.stats
    data['server_id'] = this.server_id
    data['updated_by_id'] = this.updated_by_id
    data['created_on'] = this.created_on
      ? this.created_on.toISOString()
      : <any>undefined
    data['updated_on'] = this.updated_on
      ? this.updated_on.toISOString()
      : <any>undefined
    return data
  }
}

export interface IBan_Public {
  id?: number | undefined
  ban_type: string
  expires_on?: Date | undefined
  steamid64?: number | undefined
  player_name?: string | undefined
  steam_id?: string | undefined
  notes?: string | undefined
  stats?: string | undefined
  server_id?: number | undefined
  updated_by_id?: number | undefined
  created_on?: Date | undefined
  updated_on?: Date | undefined
}

export class Ban implements IBan {
  id?: number | undefined
  ban_type!: string
  expires_on?: Date | undefined
  ip?: string | undefined
  steamid64?: number | undefined
  player_name?: string | undefined
  steam_id?: string | undefined
  notes?: string | undefined
  stats?: string | undefined
  server_id?: number | undefined
  updated_by_id?: number | undefined
  created_on?: Date | undefined
  updated_on?: Date | undefined
  server?: Server | undefined
  steamUser?: SteamUser | undefined

  constructor(data?: IBan) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.ban_type = _data['ban_type']
      this.expires_on = _data['expires_on']
        ? new Date(_data['expires_on'].toString())
        : <any>undefined
      this.ip = _data['ip']
      this.steamid64 = _data['steamid64']
      this.player_name = _data['player_name']
      this.steam_id = _data['steam_id']
      this.notes = _data['notes']
      this.stats = _data['stats']
      this.server_id = _data['server_id']
      this.updated_by_id = _data['updated_by_id']
      this.created_on = _data['created_on']
        ? new Date(_data['created_on'].toString())
        : <any>undefined
      this.updated_on = _data['updated_on']
        ? new Date(_data['updated_on'].toString())
        : <any>undefined
      this.server = _data['server']
        ? Server.fromJS(_data['server'])
        : <any>undefined
      this.steamUser = _data['steamUser']
        ? SteamUser.fromJS(_data['steamUser'])
        : <any>undefined
    }
  }

  static fromJS(data: any): Ban {
    data = typeof data === 'object' ? data : {}
    let result = new Ban()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['ban_type'] = this.ban_type
    data['expires_on'] = this.expires_on
      ? this.expires_on.toISOString()
      : <any>undefined
    data['ip'] = this.ip
    data['steamid64'] = this.steamid64
    data['player_name'] = this.player_name
    data['steam_id'] = this.steam_id
    data['notes'] = this.notes
    data['stats'] = this.stats
    data['server_id'] = this.server_id
    data['updated_by_id'] = this.updated_by_id
    data['created_on'] = this.created_on
      ? this.created_on.toISOString()
      : <any>undefined
    data['updated_on'] = this.updated_on
      ? this.updated_on.toISOString()
      : <any>undefined
    data['server'] = this.server ? this.server.toJSON() : <any>undefined
    data['steamUser'] = this.steamUser
      ? this.steamUser.toJSON()
      : <any>undefined
    return data
  }
}

export interface IBan {
  id?: number | undefined
  ban_type: string
  expires_on?: Date | undefined
  ip?: string | undefined
  steamid64?: number | undefined
  player_name?: string | undefined
  steam_id?: string | undefined
  notes?: string | undefined
  stats?: string | undefined
  server_id?: number | undefined
  updated_by_id?: number | undefined
  created_on?: Date | undefined
  updated_on?: Date | undefined
  server?: Server | undefined
  steamUser?: SteamUser | undefined
}

export class Server implements IServer {
  id?: number | undefined
  api_key?: string | undefined
  port?: number | undefined
  ip?: string | undefined
  name?: string | undefined
  owner_steamid64?: number | undefined
  created_on?: Date | undefined
  updated_on?: Date | undefined
  approval_status?: number | undefined
  approved_by_steamid64?: number | undefined

  constructor(data?: IServer) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.api_key = _data['api_key']
      this.port = _data['port']
      this.ip = _data['ip']
      this.name = _data['name']
      this.owner_steamid64 = _data['owner_steamid64']
      this.created_on = _data['created_on']
        ? new Date(_data['created_on'].toString())
        : <any>undefined
      this.updated_on = _data['updated_on']
        ? new Date(_data['updated_on'].toString())
        : <any>undefined
      this.approval_status = _data['approval_status']
      this.approved_by_steamid64 = _data['approved_by_steamid64']
    }
  }

  static fromJS(data: any): Server {
    data = typeof data === 'object' ? data : {}
    let result = new Server()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['api_key'] = this.api_key
    data['port'] = this.port
    data['ip'] = this.ip
    data['name'] = this.name
    data['owner_steamid64'] = this.owner_steamid64
    data['created_on'] = this.created_on
      ? this.created_on.toISOString()
      : <any>undefined
    data['updated_on'] = this.updated_on
      ? this.updated_on.toISOString()
      : <any>undefined
    data['approval_status'] = this.approval_status
    data['approved_by_steamid64'] = this.approved_by_steamid64
    return data
  }
}

export interface IServer {
  id?: number | undefined
  api_key?: string | undefined
  port?: number | undefined
  ip?: string | undefined
  name?: string | undefined
  owner_steamid64?: number | undefined
  created_on?: Date | undefined
  updated_on?: Date | undefined
  approval_status?: number | undefined
  approved_by_steamid64?: number | undefined
}

export class SteamUser implements ISteamUser {
  steamid?: number | undefined
  communityvisibilitystate?: number | undefined
  profilestate?: number | undefined
  personaname?: string | undefined
  lastlogoff?: number | undefined
  commentpermission?: number | undefined
  profileurl?: string | undefined
  avatar?: string | undefined
  avatarmedium?: string | undefined
  avatarfull?: string | undefined
  personastate?: number | undefined
  primaryclanid?: string | undefined
  timecreated?: number | undefined
  personastateflags?: number | undefined
  loccountrycode?: string | undefined

  constructor(data?: ISteamUser) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.steamid = _data['steamid']
      this.communityvisibilitystate = _data['communityvisibilitystate']
      this.profilestate = _data['profilestate']
      this.personaname = _data['personaname']
      this.lastlogoff = _data['lastlogoff']
      this.commentpermission = _data['commentpermission']
      this.profileurl = _data['profileurl']
      this.avatar = _data['avatar']
      this.avatarmedium = _data['avatarmedium']
      this.avatarfull = _data['avatarfull']
      this.personastate = _data['personastate']
      this.primaryclanid = _data['primaryclanid']
      this.timecreated = _data['timecreated']
      this.personastateflags = _data['personastateflags']
      this.loccountrycode = _data['loccountrycode']
    }
  }

  static fromJS(data: any): SteamUser {
    data = typeof data === 'object' ? data : {}
    let result = new SteamUser()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['steamid'] = this.steamid
    data['communityvisibilitystate'] = this.communityvisibilitystate
    data['profilestate'] = this.profilestate
    data['personaname'] = this.personaname
    data['lastlogoff'] = this.lastlogoff
    data['commentpermission'] = this.commentpermission
    data['profileurl'] = this.profileurl
    data['avatar'] = this.avatar
    data['avatarmedium'] = this.avatarmedium
    data['avatarfull'] = this.avatarfull
    data['personastate'] = this.personastate
    data['primaryclanid'] = this.primaryclanid
    data['timecreated'] = this.timecreated
    data['personastateflags'] = this.personastateflags
    data['loccountrycode'] = this.loccountrycode
    return data
  }
}

export interface ISteamUser {
  steamid?: number | undefined
  communityvisibilitystate?: number | undefined
  profilestate?: number | undefined
  personaname?: string | undefined
  lastlogoff?: number | undefined
  commentpermission?: number | undefined
  profileurl?: string | undefined
  avatar?: string | undefined
  avatarmedium?: string | undefined
  avatarfull?: string | undefined
  personastate?: number | undefined
  primaryclanid?: string | undefined
  timecreated?: number | undefined
  personastateflags?: number | undefined
  loccountrycode?: string | undefined
}

export class Jumpstat implements IJumpstat {
  id?: number | undefined
  server_id?: number | undefined
  steamid64?: number | undefined
  jumpstat_data_id?: number | undefined
  player_name?: string | undefined
  steam_id?: string | undefined
  jump_type?: JumpstatJump_type | undefined
  distance?: number | undefined
  json_jump_info?: string | undefined
  tickrate?: number | undefined
  msl_count?: number | undefined
  strafe_count?: number | undefined
  is_crouch_bind?: number | undefined
  is_forward_bind?: number | undefined
  is_crouch_boost?: number | undefined
  updated_by_id?: number | undefined
  created_on?: Date | undefined
  updated_on?: Date | undefined

  constructor(data?: IJumpstat) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.server_id = _data['server_id']
      this.steamid64 = _data['steamid64']
      this.jumpstat_data_id = _data['jumpstat_data_id']
      this.player_name = _data['player_name']
      this.steam_id = _data['steam_id']
      this.jump_type = _data['jump_type']
      this.distance = _data['distance']
      this.json_jump_info = _data['json_jump_info']
      this.tickrate = _data['tickrate']
      this.msl_count = _data['msl_count']
      this.strafe_count = _data['strafe_count']
      this.is_crouch_bind = _data['is_crouch_bind']
      this.is_forward_bind = _data['is_forward_bind']
      this.is_crouch_boost = _data['is_crouch_boost']
      this.updated_by_id = _data['updated_by_id']
      this.created_on = _data['created_on']
        ? new Date(_data['created_on'].toString())
        : <any>undefined
      this.updated_on = _data['updated_on']
        ? new Date(_data['updated_on'].toString())
        : <any>undefined
    }
  }

  static fromJS(data: any): Jumpstat {
    data = typeof data === 'object' ? data : {}
    let result = new Jumpstat()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['server_id'] = this.server_id
    data['steamid64'] = this.steamid64
    data['jumpstat_data_id'] = this.jumpstat_data_id
    data['player_name'] = this.player_name
    data['steam_id'] = this.steam_id
    data['jump_type'] = this.jump_type
    data['distance'] = this.distance
    data['json_jump_info'] = this.json_jump_info
    data['tickrate'] = this.tickrate
    data['msl_count'] = this.msl_count
    data['strafe_count'] = this.strafe_count
    data['is_crouch_bind'] = this.is_crouch_bind
    data['is_forward_bind'] = this.is_forward_bind
    data['is_crouch_boost'] = this.is_crouch_boost
    data['updated_by_id'] = this.updated_by_id
    data['created_on'] = this.created_on
      ? this.created_on.toISOString()
      : <any>undefined
    data['updated_on'] = this.updated_on
      ? this.updated_on.toISOString()
      : <any>undefined
    return data
  }
}

export interface IJumpstat {
  id?: number | undefined
  server_id?: number | undefined
  steamid64?: number | undefined
  jumpstat_data_id?: number | undefined
  player_name?: string | undefined
  steam_id?: string | undefined
  jump_type?: JumpstatJump_type | undefined
  distance?: number | undefined
  json_jump_info?: string | undefined
  tickrate?: number | undefined
  msl_count?: number | undefined
  strafe_count?: number | undefined
  is_crouch_bind?: number | undefined
  is_forward_bind?: number | undefined
  is_crouch_boost?: number | undefined
  updated_by_id?: number | undefined
  created_on?: Date | undefined
  updated_on?: Date | undefined
}

export class JumpstatPlace implements IJumpstatPlace {
  id?: number | undefined
  top_30?: number | undefined

  constructor(data?: IJumpstatPlace) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.top_30 = _data['top_30']
    }
  }

  static fromJS(data: any): JumpstatPlace {
    data = typeof data === 'object' ? data : {}
    let result = new JumpstatPlace()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['top_30'] = this.top_30
    return data
  }
}

export interface IJumpstatPlace {
  id?: number | undefined
  top_30?: number | undefined
}

export class Jumpstat_Without_Full_Detail
  implements IJumpstat_Without_Full_Detail {
  id?: number | undefined
  server_id?: number | undefined
  steamid64?: number | undefined
  player_name?: string | undefined
  steam_id?: string | undefined
  jump_type?: Jumpstat_Without_Full_DetailJump_type | undefined
  distance?: number | undefined
  tickrate?: number | undefined
  msl_count?: number | undefined
  strafe_count?: number | undefined
  is_crouch_bind?: number | undefined
  is_forward_bind?: number | undefined
  is_crouch_boost?: number | undefined
  updated_by_id?: number | undefined
  created_on?: Date | undefined
  updated_on?: Date | undefined

  constructor(data?: IJumpstat_Without_Full_Detail) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.server_id = _data['server_id']
      this.steamid64 = _data['steamid64']
      this.player_name = _data['player_name']
      this.steam_id = _data['steam_id']
      this.jump_type = _data['jump_type']
      this.distance = _data['distance']
      this.tickrate = _data['tickrate']
      this.msl_count = _data['msl_count']
      this.strafe_count = _data['strafe_count']
      this.is_crouch_bind = _data['is_crouch_bind']
      this.is_forward_bind = _data['is_forward_bind']
      this.is_crouch_boost = _data['is_crouch_boost']
      this.updated_by_id = _data['updated_by_id']
      this.created_on = _data['created_on']
        ? new Date(_data['created_on'].toString())
        : <any>undefined
      this.updated_on = _data['updated_on']
        ? new Date(_data['updated_on'].toString())
        : <any>undefined
    }
  }

  static fromJS(data: any): Jumpstat_Without_Full_Detail {
    data = typeof data === 'object' ? data : {}
    let result = new Jumpstat_Without_Full_Detail()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['server_id'] = this.server_id
    data['steamid64'] = this.steamid64
    data['player_name'] = this.player_name
    data['steam_id'] = this.steam_id
    data['jump_type'] = this.jump_type
    data['distance'] = this.distance
    data['tickrate'] = this.tickrate
    data['msl_count'] = this.msl_count
    data['strafe_count'] = this.strafe_count
    data['is_crouch_bind'] = this.is_crouch_bind
    data['is_forward_bind'] = this.is_forward_bind
    data['is_crouch_boost'] = this.is_crouch_boost
    data['updated_by_id'] = this.updated_by_id
    data['created_on'] = this.created_on
      ? this.created_on.toISOString()
      : <any>undefined
    data['updated_on'] = this.updated_on
      ? this.updated_on.toISOString()
      : <any>undefined
    return data
  }
}

export interface IJumpstat_Without_Full_Detail {
  id?: number | undefined
  server_id?: number | undefined
  steamid64?: number | undefined
  player_name?: string | undefined
  steam_id?: string | undefined
  jump_type?: Jumpstat_Without_Full_DetailJump_type | undefined
  distance?: number | undefined
  tickrate?: number | undefined
  msl_count?: number | undefined
  strafe_count?: number | undefined
  is_crouch_bind?: number | undefined
  is_forward_bind?: number | undefined
  is_crouch_boost?: number | undefined
  updated_by_id?: number | undefined
  created_on?: Date | undefined
  updated_on?: Date | undefined
}

export class Map implements IMap {
  id?: number | undefined
  name?: string | undefined
  filesize?: number | undefined
  validated?: boolean | undefined
  difficulty?: number | undefined
  created_on?: Date | undefined
  updated_on?: Date | undefined
  approved_by_steamid64?: number | undefined
  workshop_url?: string | undefined
  download_url?: string | undefined

  constructor(data?: IMap) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.name = _data['name']
      this.filesize = _data['filesize']
      this.validated = _data['validated']
      this.difficulty = _data['difficulty']
      this.created_on = _data['created_on']
        ? new Date(_data['created_on'].toString())
        : <any>undefined
      this.updated_on = _data['updated_on']
        ? new Date(_data['updated_on'].toString())
        : <any>undefined
      this.approved_by_steamid64 = _data['approved_by_steamid64']
      this.workshop_url = _data['workshop_url']
      this.download_url = _data['download_url']
    }
  }

  static fromJS(data: any): Map {
    data = typeof data === 'object' ? data : {}
    let result = new Map()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    data['filesize'] = this.filesize
    data['validated'] = this.validated
    data['difficulty'] = this.difficulty
    data['created_on'] = this.created_on
      ? this.created_on.toISOString()
      : <any>undefined
    data['updated_on'] = this.updated_on
      ? this.updated_on.toISOString()
      : <any>undefined
    data['approved_by_steamid64'] = this.approved_by_steamid64
    data['workshop_url'] = this.workshop_url
    data['download_url'] = this.download_url
    return data
  }
}

export interface IMap {
  id?: number | undefined
  name?: string | undefined
  filesize?: number | undefined
  validated?: boolean | undefined
  difficulty?: number | undefined
  created_on?: Date | undefined
  updated_on?: Date | undefined
  approved_by_steamid64?: number | undefined
  workshop_url?: string | undefined
  download_url?: string | undefined
}

export class Mode implements IMode {
  id?: number | undefined
  name?: string | undefined
  description?: string | undefined
  latest_version?: number | undefined
  latest_version_description?: string | undefined
  website?: string | undefined
  repo?: string | undefined
  contact_steamid64?: number | undefined
  supported_tickrates?: number[] | undefined
  created_on?: Date | undefined
  updated_on?: Date | undefined
  updated_by_id?: number | undefined

  constructor(data?: IMode) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.name = _data['name']
      this.description = _data['description']
      this.latest_version = _data['latest_version']
      this.latest_version_description = _data['latest_version_description']
      this.website = _data['website']
      this.repo = _data['repo']
      this.contact_steamid64 = _data['contact_steamid64']
      if (Array.isArray(_data['supported_tickrates'])) {
        this.supported_tickrates = [] as any
        for (let item of _data['supported_tickrates'])
          this.supported_tickrates!.push(item)
      }
      this.created_on = _data['created_on']
        ? new Date(_data['created_on'].toString())
        : <any>undefined
      this.updated_on = _data['updated_on']
        ? new Date(_data['updated_on'].toString())
        : <any>undefined
      this.updated_by_id = _data['updated_by_id']
    }
  }

  static fromJS(data: any): Mode {
    data = typeof data === 'object' ? data : {}
    let result = new Mode()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    data['description'] = this.description
    data['latest_version'] = this.latest_version
    data['latest_version_description'] = this.latest_version_description
    data['website'] = this.website
    data['repo'] = this.repo
    data['contact_steamid64'] = this.contact_steamid64
    if (Array.isArray(this.supported_tickrates)) {
      data['supported_tickrates'] = []
      for (let item of this.supported_tickrates)
        data['supported_tickrates'].push(item)
    }
    data['created_on'] = this.created_on
      ? this.created_on.toISOString()
      : <any>undefined
    data['updated_on'] = this.updated_on
      ? this.updated_on.toISOString()
      : <any>undefined
    data['updated_by_id'] = this.updated_by_id
    return data
  }
}

export interface IMode {
  id?: number | undefined
  name?: string | undefined
  description?: string | undefined
  latest_version?: number | undefined
  latest_version_description?: string | undefined
  website?: string | undefined
  repo?: string | undefined
  contact_steamid64?: number | undefined
  supported_tickrates?: number[] | undefined
  created_on?: Date | undefined
  updated_on?: Date | undefined
  updated_by_id?: number | undefined
}

export class Player implements IPlayer {
  steamid64?: number | undefined
  steam_id?: string | undefined
  is_banned?: boolean | undefined
  total_records?: number | undefined
  name?: string | undefined

  constructor(data?: IPlayer) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.steamid64 = _data['steamid64']
      this.steam_id = _data['steam_id']
      this.is_banned = _data['is_banned']
      this.total_records = _data['total_records']
      this.name = _data['name']
    }
  }

  static fromJS(data: any): Player {
    data = typeof data === 'object' ? data : {}
    let result = new Player()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['steamid64'] = this.steamid64
    data['steam_id'] = this.steam_id
    data['is_banned'] = this.is_banned
    data['total_records'] = this.total_records
    data['name'] = this.name
    return data
  }
}

export interface IPlayer {
  steamid64?: number | undefined
  steam_id?: string | undefined
  is_banned?: boolean | undefined
  total_records?: number | undefined
  name?: string | undefined
}

export class RecordCreateView implements IRecordCreateView {
  steamid64?: number | undefined
  player_name?: string | undefined
  steam_id?: string | undefined
  map_id?: number | undefined
  stage?: number | undefined
  mode?: string | undefined
  tickrate?: number | undefined
  time?: number | undefined
  teleports?: number | undefined
  record_filter_id?: number[] | undefined

  constructor(data?: IRecordCreateView) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.steamid64 = _data['steamid64']
      this.player_name = _data['player_name']
      this.steam_id = _data['steam_id']
      this.map_id = _data['map_id']
      this.stage = _data['stage']
      this.mode = _data['mode']
      this.tickrate = _data['tickrate']
      this.time = _data['time']
      this.teleports = _data['teleports']
      if (Array.isArray(_data['record_filter_id'])) {
        this.record_filter_id = [] as any
        for (let item of _data['record_filter_id'])
          this.record_filter_id!.push(item)
      }
    }
  }

  static fromJS(data: any): RecordCreateView {
    data = typeof data === 'object' ? data : {}
    let result = new RecordCreateView()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['steamid64'] = this.steamid64
    data['player_name'] = this.player_name
    data['steam_id'] = this.steam_id
    data['map_id'] = this.map_id
    data['stage'] = this.stage
    data['mode'] = this.mode
    data['tickrate'] = this.tickrate
    data['time'] = this.time
    data['teleports'] = this.teleports
    if (Array.isArray(this.record_filter_id)) {
      data['record_filter_id'] = []
      for (let item of this.record_filter_id)
        data['record_filter_id'].push(item)
    }
    return data
  }
}

export interface IRecordCreateView {
  steamid64?: number | undefined
  player_name?: string | undefined
  steam_id?: string | undefined
  map_id?: number | undefined
  stage?: number | undefined
  mode?: string | undefined
  tickrate?: number | undefined
  time?: number | undefined
  teleports?: number | undefined
  record_filter_id?: number[] | undefined
}

export class ServerCreateDTO implements IServerCreateDTO {
  port?: number | undefined
  ip?: string | undefined
  name?: string | undefined
  owner_steamid64?: number | undefined

  constructor(data?: IServerCreateDTO) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.port = _data['port']
      this.ip = _data['ip']
      this.name = _data['name']
      this.owner_steamid64 = _data['owner_steamid64']
    }
  }

  static fromJS(data: any): ServerCreateDTO {
    data = typeof data === 'object' ? data : {}
    let result = new ServerCreateDTO()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['port'] = this.port
    data['ip'] = this.ip
    data['name'] = this.name
    data['owner_steamid64'] = this.owner_steamid64
    return data
  }
}

export interface IServerCreateDTO {
  port?: number | undefined
  ip?: string | undefined
  name?: string | undefined
  owner_steamid64?: number | undefined
}

export enum JumpstatJump_type {
  _0 = 0,
  _1 = 1,
  _2 = 2,
  _3 = 3,
  _4 = 4,
  _5 = 5,
  _6 = 6,
  _7 = 7,
  _8 = 8,
}

export enum Jumpstat_Without_Full_DetailJump_type {
  _0 = 0,
  _1 = 1,
  _2 = 2,
  _3 = 3,
  _4 = 4,
  _5 = 5,
  _6 = 6,
  _7 = 7,
  _8 = 8,
}

export class ApiException extends Error {
  message: string
  status: number
  response: string
  headers: { [key: string]: any }
  result: any

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any
  ) {
    super()

    this.message = message
    this.status = status
    this.response = response
    this.headers = headers
    this.result = result
  }

  protected isApiException = true

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any
): any {
  if (result !== null && result !== undefined) throw result
  else throw new ApiException(message, status, response, headers, null)
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
  return obj && obj.isAxiosError === true
}
